import {
  ACESFilmicToneMapping,
  BufferAttribute,
  Camera,
  Clock,
  Color,
  LoadingManager,
  OrthographicCamera,
  PCFSoftShadowMap,
  PerspectiveCamera,
  Raycaster,
  SRGBColorSpace,
  Scene,
  TextureLoader,
  Vector2,
  Vector3,
  WebGLRenderer,
  three_module_exports
} from "./chunk-EZIVK2ET.js";
import {
  computed,
  createElementBlock,
  createRenderer,
  customRef,
  defineComponent,
  getCurrentInstance,
  getCurrentScope,
  inject,
  isRef,
  nextTick,
  normalizeStyle,
  onMounted,
  onScopeDispose,
  onUnmounted,
  openBlock,
  provide,
  reactive,
  readonly,
  ref,
  shallowRef,
  toRefs,
  unref,
  useSlots,
  watch,
  watchEffect
} from "./chunk-G4DFXOZZ.js";
import "./chunk-Y4AOG3KG.js";

// node_modules/@vueuse/shared/index.mjs
function tryOnScopeDispose(fn) {
  if (getCurrentScope()) {
    onScopeDispose(fn);
    return true;
  }
  return false;
}
function createEventHook() {
  const fns = /* @__PURE__ */ new Set();
  const off = (fn) => {
    fns.delete(fn);
  };
  const on = (fn) => {
    fns.add(fn);
    const offFn = () => off(fn);
    tryOnScopeDispose(offFn);
    return {
      off: offFn
    };
  };
  const trigger = (param) => {
    return Promise.all(Array.from(fns).map((fn) => fn(param)));
  };
  return {
    on,
    off,
    trigger
  };
}
function toValue(r) {
  return typeof r === "function" ? r() : unref(r);
}
var isClient = typeof window !== "undefined";
var noop = () => {
};
var isIOS = getIsIOS();
function getIsIOS() {
  var _a;
  return isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
}
function cacheStringFunction(fn) {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cacheStringFunction(
  (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
);
var camelizeRE = /-(\w)/g;
var camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
});
function identity(arg) {
  return arg;
}
function objectPick(obj, keys2, omitUndefined = false) {
  return keys2.reduce((n, k2) => {
    if (k2 in obj) {
      if (!omitUndefined || obj[k2] !== void 0)
        n[k2] = obj[k2];
    }
    return n;
  }, {});
}
var __defProp$9 = Object.defineProperty;
var __defProps$7 = Object.defineProperties;
var __getOwnPropDescs$7 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$b = Object.getOwnPropertySymbols;
var __hasOwnProp$b = Object.prototype.hasOwnProperty;
var __propIsEnum$b = Object.prototype.propertyIsEnumerable;
var __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$9 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$b.call(b, prop))
      __defNormalProp$9(a, prop, b[prop]);
  if (__getOwnPropSymbols$b)
    for (var prop of __getOwnPropSymbols$b(b)) {
      if (__propIsEnum$b.call(b, prop))
        __defNormalProp$9(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$7 = (a, b) => __defProps$7(a, __getOwnPropDescs$7(b));
function toRefs2(objectRef, options = {}) {
  if (!isRef(objectRef))
    return toRefs(objectRef);
  const result = Array.isArray(objectRef.value) ? Array.from({ length: objectRef.value.length }) : {};
  for (const key in objectRef.value) {
    result[key] = customRef(() => ({
      get() {
        return objectRef.value[key];
      },
      set(v) {
        var _a;
        const replaceRef = (_a = toValue(options.replaceRef)) != null ? _a : true;
        if (replaceRef) {
          if (Array.isArray(objectRef.value)) {
            const copy = [...objectRef.value];
            copy[key] = v;
            objectRef.value = copy;
          } else {
            const newObject = __spreadProps$7(__spreadValues$9({}, objectRef.value), { [key]: v });
            Object.setPrototypeOf(newObject, Object.getPrototypeOf(objectRef.value));
            objectRef.value = newObject;
          }
        } else {
          objectRef.value[key] = v;
        }
      }
    }));
  }
  return result;
}
function tryOnMounted(fn, sync = true) {
  if (getCurrentInstance())
    onMounted(fn);
  else if (sync)
    fn();
  else
    nextTick(fn);
}

// node_modules/@vueuse/core/index.mjs
function unrefElement(elRef) {
  var _a;
  const plain = toValue(elRef);
  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;
}
var defaultWindow = isClient ? window : void 0;
var defaultDocument = isClient ? window.document : void 0;
var defaultNavigator = isClient ? window.navigator : void 0;
var defaultLocation = isClient ? window.location : void 0;
function useEventListener(...args) {
  let target;
  let events;
  let listeners;
  let options;
  if (typeof args[0] === "string" || Array.isArray(args[0])) {
    [events, listeners, options] = args;
    target = defaultWindow;
  } else {
    [target, events, listeners, options] = args;
  }
  if (!target)
    return noop;
  if (!Array.isArray(events))
    events = [events];
  if (!Array.isArray(listeners))
    listeners = [listeners];
  const cleanups = [];
  const cleanup = () => {
    cleanups.forEach((fn) => fn());
    cleanups.length = 0;
  };
  const register = (el, event, listener, options2) => {
    el.addEventListener(event, listener, options2);
    return () => el.removeEventListener(event, listener, options2);
  };
  const stopWatch = watch(
    () => [unrefElement(target), toValue(options)],
    ([el, options2]) => {
      cleanup();
      if (!el)
        return;
      cleanups.push(
        ...events.flatMap((event) => {
          return listeners.map((listener) => register(el, event, listener, options2));
        })
      );
    },
    { immediate: true, flush: "post" }
  );
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(stop);
  return stop;
}
function useMounted() {
  const isMounted = ref(false);
  if (getCurrentInstance()) {
    onMounted(() => {
      isMounted.value = true;
    });
  }
  return isMounted;
}
function useSupported(callback) {
  const isMounted = useMounted();
  return computed(() => {
    isMounted.value;
    return Boolean(callback());
  });
}
function useRafFn(fn, options = {}) {
  const {
    immediate = true,
    window: window2 = defaultWindow
  } = options;
  const isActive = ref(false);
  let previousFrameTimestamp = 0;
  let rafId = null;
  function loop(timestamp2) {
    if (!isActive.value || !window2)
      return;
    const delta = timestamp2 - (previousFrameTimestamp || timestamp2);
    fn({ delta, timestamp: timestamp2 });
    previousFrameTimestamp = timestamp2;
    rafId = window2.requestAnimationFrame(loop);
  }
  function resume() {
    if (!isActive.value && window2) {
      isActive.value = true;
      rafId = window2.requestAnimationFrame(loop);
    }
  }
  function pause() {
    isActive.value = false;
    if (rafId != null && window2) {
      window2.cancelAnimationFrame(rafId);
      rafId = null;
    }
  }
  if (immediate)
    resume();
  tryOnScopeDispose(pause);
  return {
    isActive: readonly(isActive),
    pause,
    resume
  };
}
function useMediaQuery(query, options = {}) {
  const { window: window2 = defaultWindow } = options;
  const isSupported = useSupported(() => window2 && "matchMedia" in window2 && typeof window2.matchMedia === "function");
  let mediaQuery;
  const matches = ref(false);
  const handler = (event) => {
    matches.value = event.matches;
  };
  const cleanup = () => {
    if (!mediaQuery)
      return;
    if ("removeEventListener" in mediaQuery)
      mediaQuery.removeEventListener("change", handler);
    else
      mediaQuery.removeListener(handler);
  };
  const stopWatch = watchEffect(() => {
    if (!isSupported.value)
      return;
    cleanup();
    mediaQuery = window2.matchMedia(toValue(query));
    if ("addEventListener" in mediaQuery)
      mediaQuery.addEventListener("change", handler);
    else
      mediaQuery.addListener(handler);
    matches.value = mediaQuery.matches;
  });
  tryOnScopeDispose(() => {
    stopWatch();
    cleanup();
    mediaQuery = void 0;
  });
  return matches;
}
var _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var globalKey = "__vueuse_ssr_handlers__";
var handlers = getHandlers();
function getHandlers() {
  if (!(globalKey in _global))
    _global[globalKey] = _global[globalKey] || {};
  return _global[globalKey];
}
function useDevicePixelRatio({
  window: window2 = defaultWindow
} = {}) {
  const pixelRatio = ref(1);
  if (window2) {
    let observe = function() {
      pixelRatio.value = window2.devicePixelRatio;
      cleanup();
      media = window2.matchMedia(`(resolution: ${pixelRatio.value}dppx)`);
      media.addEventListener("change", observe, { once: true });
    }, cleanup = function() {
      media == null ? void 0 : media.removeEventListener("change", observe);
    };
    let media;
    observe();
    tryOnScopeDispose(cleanup);
  }
  return { pixelRatio };
}
var __getOwnPropSymbols$h = Object.getOwnPropertySymbols;
var __hasOwnProp$h = Object.prototype.hasOwnProperty;
var __propIsEnum$h = Object.prototype.propertyIsEnumerable;
var __objRest$2 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$h.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$h)
    for (var prop of __getOwnPropSymbols$h(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$h.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function useResizeObserver(target, callback, options = {}) {
  const _a = options, { window: window2 = defaultWindow } = _a, observerOptions = __objRest$2(_a, ["window"]);
  let observer;
  const isSupported = useSupported(() => window2 && "ResizeObserver" in window2);
  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  const targets = computed(
    () => Array.isArray(target) ? target.map((el) => unrefElement(el)) : [unrefElement(target)]
  );
  const stopWatch = watch(
    targets,
    (els) => {
      cleanup();
      if (isSupported.value && window2) {
        observer = new ResizeObserver(callback);
        for (const _el of els)
          _el && observer.observe(_el, observerOptions);
      }
    },
    { immediate: true, flush: "post", deep: true }
  );
  const stop = () => {
    cleanup();
    stopWatch();
  };
  tryOnScopeDispose(stop);
  return {
    isSupported,
    stop
  };
}
function useElementBounding(target, options = {}) {
  const {
    reset = true,
    windowResize = true,
    windowScroll = true,
    immediate = true
  } = options;
  const height = ref(0);
  const bottom = ref(0);
  const left = ref(0);
  const right = ref(0);
  const top = ref(0);
  const width = ref(0);
  const x = ref(0);
  const y = ref(0);
  function update() {
    const el = unrefElement(target);
    if (!el) {
      if (reset) {
        height.value = 0;
        bottom.value = 0;
        left.value = 0;
        right.value = 0;
        top.value = 0;
        width.value = 0;
        x.value = 0;
        y.value = 0;
      }
      return;
    }
    const rect = el.getBoundingClientRect();
    height.value = rect.height;
    bottom.value = rect.bottom;
    left.value = rect.left;
    right.value = rect.right;
    top.value = rect.top;
    width.value = rect.width;
    x.value = rect.x;
    y.value = rect.y;
  }
  useResizeObserver(target, update);
  watch(() => unrefElement(target), (ele) => !ele && update());
  if (windowScroll)
    useEventListener("scroll", update, { capture: true, passive: true });
  if (windowResize)
    useEventListener("resize", update, { passive: true });
  tryOnMounted(() => {
    if (immediate)
      update();
  });
  return {
    height,
    bottom,
    left,
    right,
    top,
    width,
    x,
    y,
    update
  };
}
function useElementSize(target, initialSize = { width: 0, height: 0 }, options = {}) {
  const { window: window2 = defaultWindow, box = "content-box" } = options;
  const isSVG = computed(() => {
    var _a, _b;
    return (_b = (_a = unrefElement(target)) == null ? void 0 : _a.namespaceURI) == null ? void 0 : _b.includes("svg");
  });
  const width = ref(initialSize.width);
  const height = ref(initialSize.height);
  useResizeObserver(
    target,
    ([entry]) => {
      const boxSize = box === "border-box" ? entry.borderBoxSize : box === "content-box" ? entry.contentBoxSize : entry.devicePixelContentBoxSize;
      if (window2 && isSVG.value) {
        const $elem = unrefElement(target);
        if ($elem) {
          const styles = window2.getComputedStyle($elem);
          width.value = Number.parseFloat(styles.width);
          height.value = Number.parseFloat(styles.height);
        }
      } else {
        if (boxSize) {
          const formatBoxSize = Array.isArray(boxSize) ? boxSize : [boxSize];
          width.value = formatBoxSize.reduce((acc, { inlineSize }) => acc + inlineSize, 0);
          height.value = formatBoxSize.reduce((acc, { blockSize }) => acc + blockSize, 0);
        } else {
          width.value = entry.contentRect.width;
          height.value = entry.contentRect.height;
        }
      }
    },
    options
  );
  watch(
    () => unrefElement(target),
    (ele) => {
      width.value = ele ? initialSize.width : 0;
      height.value = ele ? initialSize.height : 0;
    }
  );
  return {
    width,
    height
  };
}
var __defProp$6 = Object.defineProperty;
var __defProps$2 = Object.defineProperties;
var __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;
var __hasOwnProp$6 = Object.prototype.hasOwnProperty;
var __propIsEnum$6 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$6 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$6.call(b, prop))
      __defNormalProp$6(a, prop, b[prop]);
  if (__getOwnPropSymbols$6)
    for (var prop of __getOwnPropSymbols$6(b)) {
      if (__propIsEnum$6.call(b, prop))
        __defNormalProp$6(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));
var defaultState = {
  x: 0,
  y: 0,
  pointerId: 0,
  pressure: 0,
  tiltX: 0,
  tiltY: 0,
  width: 0,
  height: 0,
  twist: 0,
  pointerType: null
};
var keys = Object.keys(defaultState);
function usePointer(options = {}) {
  const {
    target = defaultWindow
  } = options;
  const isInside = ref(false);
  const state = ref(options.initialValue || {});
  Object.assign(state.value, defaultState, state.value);
  const handler = (event) => {
    isInside.value = true;
    if (options.pointerTypes && !options.pointerTypes.includes(event.pointerType))
      return;
    state.value = objectPick(event, keys, false);
  };
  if (target) {
    const listenerOptions = { passive: true };
    useEventListener(target, ["pointerdown", "pointermove", "pointerup"], handler, listenerOptions);
    useEventListener(target, "pointerleave", () => isInside.value = false, listenerOptions);
  }
  return __spreadProps$2(__spreadValues$6({}, toRefs2(state)), {
    isInside
  });
}
var DEFAULT_UNITS = [
  { max: 6e4, value: 1e3, name: "second" },
  { max: 276e4, value: 6e4, name: "minute" },
  { max: 72e6, value: 36e5, name: "hour" },
  { max: 5184e5, value: 864e5, name: "day" },
  { max: 24192e5, value: 6048e5, name: "week" },
  { max: 28512e6, value: 2592e6, name: "month" },
  { max: Number.POSITIVE_INFINITY, value: 31536e6, name: "year" }
];
var _TransitionPresets = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
var TransitionPresets = Object.assign({}, { linear: identity }, _TransitionPresets);
function useWindowSize(options = {}) {
  const {
    window: window2 = defaultWindow,
    initialWidth = Number.POSITIVE_INFINITY,
    initialHeight = Number.POSITIVE_INFINITY,
    listenOrientation = true,
    includeScrollbar = true
  } = options;
  const width = ref(initialWidth);
  const height = ref(initialHeight);
  const update = () => {
    if (window2) {
      if (includeScrollbar) {
        width.value = window2.innerWidth;
        height.value = window2.innerHeight;
      } else {
        width.value = window2.document.documentElement.clientWidth;
        height.value = window2.document.documentElement.clientHeight;
      }
    }
  };
  update();
  tryOnMounted(update);
  useEventListener("resize", update, { passive: true });
  if (listenOrientation) {
    const matches = useMediaQuery("(orientation: portrait)");
    watch(matches, () => update());
  }
  return { width, height };
}

// node_modules/@tresjs/core/dist/tres.js
var X = ref({});
var $ = (e) => void Object.assign(X.value, e);
var N = (e) => typeof e == "function";
var Y = (e) => !!e && e.constructor === Array;
var Oe = ({ sizes: e, scene: a }) => {
  const t = ref([]), n = computed(
    () => t.value[0]
  ), r = (o, s = false) => {
    t.value.some(({ uuid: u }) => u === o.uuid) || (s ? l(o) : t.value.push(o));
  }, i = (o) => {
    t.value = t.value.filter(({ uuid: s }) => s !== o.uuid);
  }, l = (o) => {
    const s = o instanceof Camera ? o : t.value.find((c) => c.uuid === o);
    if (!s)
      return;
    const u = t.value.filter(({ uuid: c }) => c !== s.uuid);
    t.value = [s, ...u];
  };
  return watchEffect(() => {
    e.aspectRatio.value && t.value.forEach((o) => {
      o instanceof PerspectiveCamera && (o.aspect = e.aspectRatio.value), (o instanceof PerspectiveCamera || o instanceof OrthographicCamera) && o.updateProjectionMatrix();
    });
  }), a.userData.tres__registerCamera = r, a.userData.tres__deregisterCamera = i, onUnmounted(() => {
    t.value = [];
  }), {
    camera: n,
    cameras: t,
    addCamera: r,
    removeCamera: i,
    setCameraActive: l
  };
};
var Q = createEventHook();
var Z = createEventHook();
var I = createEventHook();
var D = new Clock();
var R = 0;
var F = 0;
var { pause: Re, resume: Fe, isActive: ze } = useRafFn(
  () => {
    Q.trigger({ delta: R, elapsed: F, clock: D }), Z.trigger({ delta: R, elapsed: F, clock: D }), I.trigger({ delta: R, elapsed: F, clock: D });
  },
  { immediate: false }
);
I.on(() => {
  R = D.getDelta(), F = D.getElapsedTime();
});
var ee = () => ({
  onBeforeLoop: Q.on,
  onLoop: Z.on,
  onAfterLoop: I.on,
  pause: Re,
  resume: Fe,
  isActive: ze
});
var h2 = {
  realistic: {
    outputColorSpace: SRGBColorSpace,
    toneMapping: ACESFilmicToneMapping,
    toneMappingExposure: 3,
    shadowMap: {
      enabled: true,
      type: PCFSoftShadowMap
    }
  }
};
var te = (e, a) => {
  for (const t of Object.keys(a))
    a[t] instanceof Object && Object.assign(a[t], te(e[t], a[t]));
  return Object.assign(e || {}, a), e;
};
var He = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
var Ve = Ge(He);
function B(e) {
  return e.replace(/-([a-z])/g, (a, t) => t.toUpperCase());
}
function Ge(e, a) {
  const t = /* @__PURE__ */ Object.create(null), n = e.split(",");
  for (let r = 0; r < n.length; r++)
    t[n[r]] = true;
  return a ? (r) => !!t[r.toLowerCase()] : (r) => !!t[r];
}
var We = (e, a) => {
  const t = /* @__PURE__ */ new Set(), n = [];
  for (const r of e) {
    const i = a(r);
    t.has(i) || (t.add(i), n.push(r));
  }
  return n;
};
var q = (e, a) => {
  if (!a)
    return;
  const t = Array.isArray(a) ? a : a.match(/([^[.\]])+/g);
  return t == null ? void 0 : t.reduce((n, r) => n && n[r], e);
};
var je = (e, a, t) => {
  const n = Array.isArray(a) ? a : a.match(/([^[.\]])+/g);
  n && n.reduce((r, i, l) => (r[i] === void 0 && (r[i] = {}), l === n.length - 1 && (r[i] = t), r[i]), e);
};
var st = true;
var U = "[TresJS ▲ ■ ●] ";
function k() {
  function e(n, r) {
    console.error(`${U} ${n}`, r || "");
  }
  function a(n) {
    console.warn(`${U} ${n}`);
  }
  function t(n, r) {
  }
  return {
    logError: e,
    logWarning: a,
    logMessage: t
  };
}
function it(e) {
  return typeof e == "number" ? [e, e, e] : e instanceof Vector3 ? [e.x, e.y, e.z] : e;
}
function $e(e) {
  return e instanceof Color ? e : Array.isArray(e) ? new Color(...e) : new Color(e);
}
function Ie({
  scene: e,
  canvas: a,
  options: t,
  disableRender: n,
  contextParts: { sizes: r, camera: i }
}) {
  const l = computed(() => ({
    alpha: toValue(t.alpha),
    depth: toValue(t.depth),
    canvas: unrefElement(a),
    context: toValue(t.context),
    stencil: toValue(t.stencil),
    antialias: toValue(t.antialias) === void 0 ? (
      // an opinionated default of tres
      true
    ) : toValue(t.antialias),
    precision: toValue(t.precision),
    powerPreference: toValue(t.powerPreference),
    premultipliedAlpha: toValue(t.premultipliedAlpha),
    preserveDrawingBuffer: toValue(t.preserveDrawingBuffer),
    logarithmicDepthBuffer: toValue(t.logarithmicDepthBuffer),
    failIfMajorPerformanceCaveat: toValue(t.failIfMajorPerformanceCaveat)
  })), o = shallowRef(new WebGLRenderer(l.value));
  watch(l, () => {
    o.value.dispose(), o.value = new WebGLRenderer(l.value);
  }), watchEffect(() => {
    o.value.setSize(r.width.value, r.height.value);
  });
  const { pixelRatio: s } = useDevicePixelRatio();
  watchEffect(() => {
    o.value.setPixelRatio(s.value);
  });
  const { logError: u } = k(), f = (() => {
    const p = new WebGLRenderer(), d = {
      shadowMap: {
        enabled: p.shadowMap.enabled,
        type: p.shadowMap.type
      },
      toneMapping: p.toneMapping,
      toneMappingExposure: p.toneMappingExposure,
      outputColorSpace: p.outputColorSpace,
      useLegacyLights: p.useLegacyLights
    };
    return p.dispose(), d;
  })();
  watchEffect(() => {
    const p = toValue(t.preset);
    p && (p in h2 || u("Renderer Preset must be one of these: " + Object.keys(h2).join(", ")), te(o.value, h2[p]));
    const d = (L, x) => {
      const T = toValue(L), S = () => {
        if (p)
          return q(h2[p], x);
      };
      if (T !== void 0)
        return T;
      const m = S();
      return m !== void 0 ? m : q(f, x);
    }, v = (L, x) => je(o.value, x, d(L, x));
    v(t.shadows, "shadowMap.enabled"), v(t.toneMapping, "toneMapping"), v(t.shadowMapType, "shadowMap.type"), v(t.useLegacyLights, "useLegacyLights"), v(t.outputColorSpace, "outputColorSpace"), v(t.toneMappingExposure, "toneMappingExposure");
    const E = d(t.clearColor, "clearColor");
    E && o.value.setClearColor(
      E ? $e(E) : new Color(0)
      // default clear color is not easily/efficiently retrievable from three
    );
  });
  const { pause: w, resume: C, onLoop: M } = ee();
  return M(() => {
    i.value && !toValue(n) && o.value.render(e, i.value);
  }), C(), onUnmounted(() => {
    w(), o.value.dispose(), o.value.forceContextLoss();
  }), {
    renderer: o
  };
}
function Ne(e) {
  const a = { nodes: {}, materials: {} };
  return e && e.traverse((t) => {
    t.name && (a.nodes[t.name] = t), t.material && !a.materials[t.material.name] && (a.materials[t.material.name] = t.material);
  }), a;
}
async function ut(e, a, t, n, r) {
  const { logError: i } = k(), l = new e();
  r && r(l), t && t(l);
  const s = (Array.isArray(a) ? a : [a]).map(
    (u) => new Promise((c, f) => {
      l.load(
        u,
        (w) => {
          w.scene && Object.assign(w, Ne(w.scene)), c(w);
        },
        n,
        (w) => f(i("[useLoader] - Failed to load resource", w))
      );
    })
  );
  return Y(a) ? await Promise.all(s) : await s[0];
}
async function lt(e) {
  const a = new LoadingManager(), t = new TextureLoader(a), n = (r) => new Promise((i, l) => {
    t.load(
      r,
      (o) => i(o),
      () => null,
      () => {
        l(new Error("[useTextures] - Failed to load texture"));
      }
    );
  });
  if (Y(e)) {
    const r = await Promise.all(e.map((i) => n(i)));
    return e.length > 1 ? r : r[0];
  } else {
    const {
      map: r,
      displacementMap: i,
      normalMap: l,
      roughnessMap: o,
      metalnessMap: s,
      aoMap: u,
      alphaMap: c,
      matcap: f
    } = e;
    return {
      map: r ? await n(r) : null,
      displacementMap: i ? await n(i) : null,
      normalMap: l ? await n(l) : null,
      roughnessMap: o ? await n(o) : null,
      metalnessMap: s ? await n(s) : null,
      aoMap: u ? await n(u) : null,
      alphaMap: c ? await n(c) : null,
      matcap: f ? await n(f) : null
    };
  }
}
var qe = (e, { renderer: a, camera: t, raycaster: n }) => {
  const r = computed(() => a.value.domElement), { x: i, y: l } = usePointer({ target: r }), { width: o, height: s, top: u, left: c } = useElementBounding(r), f = ({ x: m, y: P }) => {
    if (r.value)
      return {
        x: (m - c.value) / o.value * 2 - 1,
        y: -((P - u.value) / s.value) * 2 + 1
      };
  }, w = ({ x: m, y: P }) => {
    if (t.value)
      return n.value.setFromCamera(new Vector2(m, P), t.value), n.value.intersectObjects(e.value, false);
  }, C = (m) => {
    const P = f({
      x: (m == null ? void 0 : m.clientX) ?? i.value,
      y: (m == null ? void 0 : m.clientY) ?? l.value
    });
    return P ? w(P) || [] : [];
  }, M = computed(() => C()), p = createEventHook(), d = createEventHook(), v = (m, P) => {
    m.trigger({ event: P, intersects: C(P) });
  }, E = (m) => {
    v(d, m);
  };
  let L;
  const x = (m) => {
    var P;
    L = (P = C(m)[0]) == null ? void 0 : P.object;
  }, T = (m) => {
    var P;
    m instanceof PointerEvent && L === ((P = C(m)[0]) == null ? void 0 : P.object) && v(p, m);
  }, S = (m) => d.trigger({ event: m, intersects: [] });
  return r.value.addEventListener("pointerup", T), r.value.addEventListener("pointerdown", x), r.value.addEventListener("pointermove", E), r.value.addEventListener("pointerleave", S), onUnmounted(() => {
    r != null && r.value && (r.value.removeEventListener("pointerup", T), r.value.removeEventListener("pointerdown", x), r.value.removeEventListener("pointermove", E), r.value.removeEventListener("pointerleave", S));
  }), {
    intersects: M,
    onClick: (m) => p.on(m).off,
    onPointerMove: (m) => d.on(m).off
  };
};
function ct() {
  const { logWarning: e } = k();
  function a(n, r, i) {
    let l = null;
    return n.traverse((o) => {
      o[r] === i && (l = o);
    }), l || e(`Child with ${r} '${i}' not found.`), l;
  }
  function t(n, r) {
    return a(n, "name", r);
  }
  return {
    seek: a,
    seekByName: t
  };
}
var Ue = ({ scene: e, contextParts: a }) => {
  const t = reactive({
    click: /* @__PURE__ */ new Map(),
    pointerMove: /* @__PURE__ */ new Map(),
    pointerEnter: /* @__PURE__ */ new Map(),
    pointerLeave: /* @__PURE__ */ new Map()
  }), n = (u) => {
    Object.values(t).forEach((c) => c.delete(u));
  }, r = (u) => {
    const { onClick: c, onPointerMove: f, onPointerEnter: w, onPointerLeave: C } = u;
    c && t.click.set(u, c), f && t.pointerMove.set(u, f), w && t.pointerEnter.set(u, w), C && t.pointerLeave.set(u, C);
  };
  e.userData.tres__registerAtPointerEventHandler = r, e.userData.tres__deregisterAtPointerEventHandler = n;
  const i = computed(
    () => We(
      Object.values(t).map((u) => Array.from(u.keys())).flat(),
      ({ uuid: u }) => u
    )
  ), { onClick: l, onPointerMove: o } = qe(i, a);
  l(({ intersects: u, event: c }) => {
    var f;
    u.length && ((f = t.click.get(u[0].object)) == null || f(u[0], c));
  });
  let s;
  return o(({ intersects: u, event: c }) => {
    var p, d, v, E;
    const f = (p = u == null ? void 0 : u[0]) == null ? void 0 : p.object, { pointerLeave: w, pointerEnter: C, pointerMove: M } = t;
    s && s !== f && ((d = w.get(s)) == null || d(s, c)), f && (s !== f && ((v = C.get(f)) == null || v(u[0], c)), (E = M.get(f)) == null || E(u[0], c)), s = f || null;
  }), {
    registerObject: r,
    deregisterObject: n
  };
};
function Je({
  scene: e,
  canvas: a,
  windowSize: t,
  disableRender: n,
  rendererOptions: r
}) {
  const i = computed(
    () => toValue(t) ? useWindowSize() : useElementSize(toValue(a).parentElement)
  ), l = computed(() => i.value.width.value), o = computed(() => i.value.height.value), s = computed(() => l.value / o.value), u = {
    height: o,
    width: l,
    aspectRatio: s
  }, c = shallowRef(e), {
    camera: f,
    cameras: w,
    addCamera: C,
    removeCamera: M,
    setCameraActive: p
  } = Oe({ sizes: u, scene: e }), { renderer: d } = Ie(
    {
      scene: e,
      canvas: a,
      options: r,
      contextParts: { sizes: u, camera: f },
      disableRender: n
    }
  ), v = {
    sizes: u,
    scene: c,
    camera: f,
    cameras: readonly(w),
    renderer: d,
    raycaster: shallowRef(new Raycaster()),
    controls: ref(null),
    extend: $,
    addCamera: C,
    removeCamera: M,
    setCameraActive: p
  };
  return provide("useTres", v), v;
}
function Ke() {
  const e = inject("useTres");
  if (!e)
    throw new Error("useTresContext must be used together with useTresContextProvider");
  return e;
}
var ft = Ke;
var G = null;
var g = null;
var { logError: J } = k();
var Xe = {
  createElement(e, a, t, n) {
    var l, o;
    if (n || (n = {}), n.args || (n.args = []), e === "template" || Ve(e))
      return null;
    let r = e.replace("Tres", ""), i;
    if (e === "primitive") {
      (n == null ? void 0 : n.object) === void 0 && J("Tres primitives need a prop 'object'");
      const s = n.object;
      r = s.type, i = Object.assign(s, { type: r, attach: n.attach, primitive: true });
    } else {
      const s = X.value[r];
      s || J(`${r} is not defined on the THREE namespace. Use extend to add it to the catalog.`), i = new s(...n.args);
    }
    return i.isCamera && (n != null && n.position || i.position.set(3, 3, 3), n != null && n.lookAt || i.lookAt(0, 0, 0)), (n == null ? void 0 : n.attach) === void 0 && (i.isMaterial ? i.attach = "material" : i.isBufferGeometry && (i.attach = "geometry")), i.isObject3D && ((l = n == null ? void 0 : n.material) != null && l.isMaterial && (i.userData.tres__materialViaProp = true), (o = n == null ? void 0 : n.geometry) != null && o.isBufferGeometry && (i.userData.tres__geometryViaProp = true)), i;
  },
  insert(e, a) {
    var t, n, r, i, l, o, s, u, c;
    if (a && a.isScene && (g = a), (((t = e == null ? void 0 : e.__vnode) == null ? void 0 : t.type) === "TresGroup" || ((n = e == null ? void 0 : e.__vnode) == null ? void 0 : n.type) === "TresObject3D") && a === null && !((i = (r = e == null ? void 0 : e.__vnode) == null ? void 0 : r.ctx) != null && i.asyncResolved)) {
      G = e;
      return;
    } else
      (l = e == null ? void 0 : e.__vnode) != null && l.type.includes("Controls") && a === null && (G = g);
    if (a || (a = G), e != null && e.isObject3D) {
      if (e != null && e.isCamera) {
        if (!(g != null && g.userData.tres__registerCamera))
          throw "could not find tres__registerCamera on scene's userData";
        (s = g == null ? void 0 : (o = g.userData).tres__registerCamera) == null || s.call(o, e);
      }
      if (e != null && e.onClick || e != null && e.onPointerMove || e != null && e.onPointerEnter || e != null && e.onPointerLeave) {
        if (!(g != null && g.userData.tres__registerAtPointerEventHandler))
          throw "could not find tres__registerAtPointerEventHandler on scene's userData";
        (c = g == null ? void 0 : (u = g.userData).tres__registerAtPointerEventHandler) == null || c.call(u, e);
      }
    }
    e != null && e.isObject3D && (a != null && a.isObject3D) ? (a.add(e), e.dispatchEvent({ type: "added" })) : e != null && e.isFog ? a.fog = e : typeof (e == null ? void 0 : e.attach) == "string" && (e.__previousAttach = e[a == null ? void 0 : a.attach], a && (a[e.attach] = e));
  },
  remove(e) {
    var a, t;
    if (e) {
      if (e.isObject3D) {
        const n = e, r = (s) => {
          var c, f;
          const u = s;
          s.userData.tres__materialViaProp || (c = u.material) == null || c.dispose(), s.userData.tres__geometryViaProp || (f = u.geometry) == null || f.dispose();
        }, i = g == null ? void 0 : g.userData.tres__deregisterAtPointerEventHandler, l = (s) => {
          if (!i)
            throw "could not find tres__deregisterAtPointerEventHandler on scene's userData";
          (s != null && s.onClick || s != null && s.onPointerMove || s != null && s.onPointerEnter || s != null && s.onPointerLeave) && (i == null || i(s));
        }, o = (s) => {
          const u = g == null ? void 0 : g.userData.tres__deregisterCamera;
          if (!u)
            throw "could not find tres__deregisterCamera on scene's userData";
          s.isCamera && (u == null || u(s));
        };
        n.traverse((s) => {
          r(s), o(s), l == null || l(s);
        }), r(n), o(n), l == null || l(n);
      }
      (a = e.removeFromParent) == null || a.call(e), (t = e.dispose) == null || t.call(e);
    }
  },
  patchProp(e, a, t, n) {
    if (e) {
      let r = e, i = a, l = B(i), o = r == null ? void 0 : r[l];
      if (r.type === "BufferGeometry") {
        if (i === "args")
          return;
        r.setAttribute(
          B(i),
          new BufferAttribute(...n)
        );
        return;
      }
      if (i.includes("-") && o === void 0) {
        const u = i.split("-");
        o = u.reduce((c, f) => c[B(f)], r), i = u.pop(), l = i.toLowerCase(), o != null && o.set || (r = u.reduce((c, f) => c[B(f)], r));
      }
      let s = n;
      if (s === "" && (s = true), N(o)) {
        Array.isArray(s) ? e[l](...s) : e[l](s);
        return;
      }
      !(o != null && o.set) && !N(o) ? r[l] = s : o.constructor === s.constructor && (o != null && o.copy) ? o == null || o.copy(s) : Array.isArray(s) ? o.set(...s) : !o.isColor && o.setScalar ? o.setScalar(s) : o.set(s);
    }
  },
  parentNode(e) {
    return (e == null ? void 0 : e.parent) || null;
  },
  createText: () => void 0,
  createComment: () => void 0,
  setText: () => void 0,
  setElementText: () => void 0,
  nextSibling: () => void 0,
  querySelector: () => void 0,
  setScopeId: () => void 0,
  cloneNode: () => void 0,
  insertStaticContent: () => void 0
};
var { createApp: Ye } = createRenderer(Xe);
var Qe = (e) => {
  const a = Ye(t);
  function t() {
    return e && e.default ? e.default() : [];
  }
  return a;
};
$(three_module_exports);
var Ze = ["data-scene"];
var et = defineComponent({
  __name: "TresCanvas",
  props: {
    shadows: { type: Boolean },
    clearColor: {},
    toneMapping: {},
    shadowMapType: {},
    useLegacyLights: { type: Boolean },
    outputColorSpace: {},
    toneMappingExposure: {},
    windowSize: { type: Boolean },
    preset: {},
    disableRender: { type: Boolean },
    camera: {},
    context: {},
    precision: {},
    alpha: { type: Boolean, default: false },
    premultipliedAlpha: { type: Boolean },
    antialias: { type: Boolean, default: true },
    stencil: { type: Boolean, default: true },
    preserveDrawingBuffer: { type: Boolean, default: false },
    powerPreference: {},
    depth: { type: Boolean, default: true },
    logarithmicDepthBuffer: { type: Boolean },
    failIfMajorPerformanceCaveat: { type: Boolean }
  },
  setup(e) {
    const a = e, { logWarning: t } = k(), n = ref(), r = shallowRef(new Scene());
    ee();
    const i = useSlots();
    let l;
    const o = (u) => {
      l = Qe(i), l.provide("useTres", u), l.provide("extend", $), l.mount(r.value);
    }, s = computed(() => a.disableRender);
    return onMounted(() => {
      const u = n, c = Je({
        scene: r.value,
        canvas: u,
        windowSize: a.windowSize,
        disableRender: s,
        rendererOptions: a
      });
      Ue({ scene: r.value, contextParts: c });
      const { addCamera: f, camera: w, cameras: C, removeCamera: M } = c;
      o(c);
      const p = () => {
        const d = new PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1e3);
        d.position.set(3, 3, 3), d.lookAt(0, 0, 0), f(d);
        const v = watchEffect(
          () => {
            C.value.length >= 2 && (d.removeFromParent(), M(d), v == null || v());
          }
        );
      };
      watch(() => a.camera, (d, v) => {
        d ? f(d) : v && (v.removeFromParent(), M(v));
      }, {
        immediate: true
      }), w.value || (t(
        "No camera found. Creating a default perspective camera. To have full control over a camera, please add one to the scene."
      ), p());
    }), (u, c) => (openBlock(), createElementBlock("canvas", {
      ref_key: "canvas",
      ref: n,
      "data-scene": r.value.uuid,
      style: normalizeStyle({
        display: "block",
        width: "100%",
        height: "100%",
        position: u.windowSize ? "fixed" : "relative",
        top: 0,
        left: 0,
        pointerEvents: "auto",
        touchAction: "none",
        zIndex: 1
      })
    }, null, 12, Ze));
  }
});
var tt = [
  "TresCanvas",
  "TresLeches",
  "TresScene"
];
var rt = {
  template: {
    compilerOptions: {
      isCustomElement: (e) => e.startsWith("Tres") && !tt.includes(e) || e === "primitive"
    }
  }
};
var mt = rt;
var pt = {
  install(e) {
    e.component("TresCanvas", et);
  }
};
export {
  et as TresCanvas,
  X as catalogue,
  pt as default,
  $ as extend,
  st as isProd,
  $e as normalizeColor,
  it as normalizeVectorFlexibleParam,
  mt as templateCompilerOptions,
  Ne as trasverseObjects,
  Oe as useCamera,
  ut as useLoader,
  k as useLogger,
  Ue as usePointerEventHandler,
  qe as useRaycaster,
  ee as useRenderLoop,
  Ie as useRenderer,
  ct as useSeek,
  lt as useTexture,
  ft as useTres,
  Ke as useTresContext,
  Je as useTresContextProvider
};
//# sourceMappingURL=@tresjs_core.js.map
